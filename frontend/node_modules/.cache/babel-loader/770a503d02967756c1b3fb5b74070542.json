{"ast":null,"code":"var leafletControlGeocoder = function (exports, L) {\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n\n    n['default'] = e;\n    return n;\n  }\n\n  var L__namespace = /*#__PURE__*/_interopNamespace(L);\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function geocodingParams(options, params) {\n    return L__namespace.Util.extend(params, options.geocodingQueryParams);\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function reverseParams(options, params) {\n    return L__namespace.Util.extend(params, options.reverseQueryParams);\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  var lastCallbackId = 0; // Adapted from handlebars.js\n  // https://github.com/wycats/handlebars.js/\n\n  /**\r\n   * @internal\r\n   */\n\n  var badChars = /[&<>\"'`]/g;\n  /**\r\n   * @internal\r\n   */\n\n  var possible = /[&<>\"'`]/;\n  /**\r\n   * @internal\r\n   */\n\n  var escape = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  /**\r\n   * @internal\r\n   */\n\n  function escapeChar(chr) {\n    return escape[chr];\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function htmlEscape(string) {\n    if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    } // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n\n\n    string = '' + string;\n\n    if (!possible.test(string)) {\n      return string;\n    }\n\n    return string.replace(badChars, escapeChar);\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function jsonp(url, params, callback, context, jsonpParam) {\n    var callbackId = '_l_geocoder_' + lastCallbackId++;\n    params[jsonpParam || 'callback'] = callbackId;\n    window[callbackId] = L__namespace.Util.bind(callback, context);\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url + getParamString(params);\n    script.id = callbackId;\n    document.getElementsByTagName('head')[0].appendChild(script);\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function getJSON(url, params, callback) {\n    var xmlHttp = new XMLHttpRequest();\n\n    xmlHttp.onreadystatechange = function () {\n      if (xmlHttp.readyState !== 4) {\n        return;\n      }\n\n      var message;\n\n      if (xmlHttp.status !== 200 && xmlHttp.status !== 304) {\n        message = '';\n      } else if (typeof xmlHttp.response === 'string') {\n        // IE doesn't parse JSON responses even with responseType: 'json'.\n        try {\n          message = JSON.parse(xmlHttp.response);\n        } catch (e) {\n          // Not a JSON response\n          message = xmlHttp.response;\n        }\n      } else {\n        message = xmlHttp.response;\n      }\n\n      callback(message);\n    };\n\n    xmlHttp.open('GET', url + getParamString(params), true);\n    xmlHttp.responseType = 'json';\n    xmlHttp.setRequestHeader('Accept', 'application/json');\n    xmlHttp.send(null);\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function template(str, data) {\n    return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        value = '';\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return htmlEscape(value);\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      var key = encodeURIComponent(uppercase ? i.toUpperCase() : i);\n      var value = obj[i];\n\n      if (!Array.isArray(value)) {\n        params.push(key + '=' + encodeURIComponent(String(value)));\n      } else {\n        for (var j = 0; j < value.length; j++) {\n          params.push(key + '=' + encodeURIComponent(value[j]));\n        }\n      }\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n  /**\r\n   * Implementation of the [ArcGIS geocoder](https://developers.arcgis.com/features/geocoding/)\r\n   */\n\n\n  var ArcGis = /*#__PURE__*/function () {\n    function ArcGis(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer',\n        apiKey: ''\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = ArcGis.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        token: this.options.apiKey,\n        SingleLine: query,\n        outFields: 'Addr_Type',\n        forStorage: false,\n        maxLocations: 10,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/findAddressCandidates', params, function (data) {\n        var results = [];\n\n        if (data.candidates && data.candidates.length) {\n          for (var i = 0; i <= data.candidates.length - 1; i++) {\n            var loc = data.candidates[i];\n            var latLng = L__namespace.latLng(loc.location.y, loc.location.x);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.extent.ymax, loc.extent.xmax), L__namespace.latLng(loc.extent.ymin, loc.extent.xmin));\n            results[i] = {\n              name: loc.address,\n              bbox: latLngBounds,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        location: location.lng + ',' + location.lat,\n        distance: 100,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverseGeocode', params, function (data) {\n        var result = [];\n\n        if (data && !data.error) {\n          var center = L__namespace.latLng(data.location.y, data.location.x);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.address.Match_addr,\n            center: center,\n            bbox: bbox\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return ArcGis;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link ArcGis}\r\n   * @param options the options\r\n   */\n\n\n  function arcgis(options) {\n    return new ArcGis(options);\n  }\n  /**\r\n   * Implementation of the [Bing Locations API](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/)\r\n   */\n\n\n  var Bing = /*#__PURE__*/function () {\n    function Bing(options) {\n      this.options = {\n        serviceUrl: 'https://dev.virtualearth.net/REST/v1/Locations'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Bing.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        query: query,\n        key: this.options.apiKey\n      });\n      jsonp(this.options.apiKey, params, function (data) {\n        var results = [];\n\n        if (data.resourceSets.length > 0) {\n          for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n            var resource = data.resourceSets[0].resources[i],\n                bbox = resource.bbox;\n            results[i] = {\n              name: resource.name,\n              bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n              center: L__namespace.latLng(resource.point.coordinates)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey\n      });\n      jsonp(this.options.serviceUrl + location.lat + ',' + location.lng, params, function (data) {\n        var results = [];\n\n        for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n          var resource = data.resourceSets[0].resources[i],\n              bbox = resource.bbox;\n          results[i] = {\n            name: resource.name,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n            center: L__namespace.latLng(resource.point.coordinates)\n          };\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    return Bing;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Bing}\r\n   * @param options the options\r\n   */\n\n\n  function bing(options) {\n    return new Bing(options);\n  }\n\n  var Google = /*#__PURE__*/function () {\n    function Google(options) {\n      this.options = {\n        serviceUrl: 'https://maps.googleapis.com/maps/api/geocode/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Google.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        address: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var latLng = L__namespace.latLng(loc.geometry.location);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: latLngBounds,\n              center: latLng,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        latlng: location.lat + ',' + location.lng\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry.location);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: bbox,\n              center: center,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Google;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Google}\r\n   * @param options the options\r\n   */\n\n\n  function google(options) {\n    return new Google(options);\n  }\n  /**\r\n   * Implementation of the [HERE Geocoder API](https://developer.here.com/documentation/geocoder/topics/introduction.html)\r\n   */\n\n\n  var HERE = /*#__PURE__*/function () {\n    function HERE(options) {\n      this.options = {\n        serviceUrl: 'https://geocoder.api.here.com/6.2/',\n        app_id: '',\n        app_code: '',\n        apiKey: '',\n        maxResults: 5\n      };\n      L__namespace.Util.setOptions(this, options);\n      if (options.apiKey) throw Error('apiKey is not supported, use app_id/app_code instead!');\n    }\n\n    var _proto = HERE.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        searchtext: query,\n        gen: 9,\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'geocode.json', params, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var prox = location.lat + ',' + location.lng;\n\n      if (this.options.reverseGeocodeProxRadius) {\n        prox += ',' + this.options.reverseGeocodeProxRadius;\n      }\n\n      var params = reverseParams(this.options, {\n        prox: prox,\n        mode: 'retrieveAddresses',\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        gen: 9,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'reversegeocode.json', params, cb, context);\n    };\n\n    _proto.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.response.view && data.response.view.length) {\n          for (var i = 0; i <= data.response.view[0].result.length - 1; i++) {\n            var loc = data.response.view[0].result[i].location;\n            var center = L__namespace.latLng(loc.displayPosition.latitude, loc.displayPosition.longitude);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.mapView.topLeft.latitude, loc.mapView.topLeft.longitude), L__namespace.latLng(loc.mapView.bottomRight.latitude, loc.mapView.bottomRight.longitude));\n            results[i] = {\n              name: loc.address.label,\n              properties: loc.address,\n              bbox: bbox,\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HERE;\n  }();\n  /**\r\n   * Implementation of the new [HERE Geocoder API](https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html)\r\n   */\n\n\n  var HEREv2 = /*#__PURE__*/function () {\n    function HEREv2(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.search.hereapi.com/v1',\n        apiKey: '',\n        app_id: '',\n        app_code: '',\n        maxResults: 10\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto2 = HEREv2.prototype;\n\n    _proto2.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query,\n        apiKey: this.options.apiKey,\n        limit: this.options.maxResults\n      });\n\n      if (!params.at && !params[\"in\"]) {\n        throw Error('at / in parameters not found. Please define coordinates (at=latitude,longitude) or other (in) in your geocodingQueryParams.');\n      }\n\n      this.getJSON(this.options.serviceUrl + '/discover', params, cb, context);\n    };\n\n    _proto2.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        at: location.lat + ',' + location.lng,\n        limit: this.options.reverseGeocodeProxRadius,\n        apiKey: this.options.apiKey\n      });\n      this.getJSON(this.options.serviceUrl + '/revgeocode', params, cb, context);\n    };\n\n    _proto2.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.items && data.items.length) {\n          for (var i = 0; i <= data.items.length - 1; i++) {\n            var item = data.items[i];\n            var latLng = L__namespace.latLng(item.position.lat, item.position.lng);\n            var bbox = void 0;\n\n            if (item.mapView) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.mapView.south, item.mapView.west), L__namespace.latLng(item.mapView.north, item.mapView.east));\n            } else {\n              // Using only position when not provided\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.position.lat, item.position.lng), L__namespace.latLng(item.position.lat, item.position.lng));\n            }\n\n            results[i] = {\n              name: item.address.label,\n              properties: item.address,\n              bbox: bbox,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HEREv2;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link HERE}\r\n   * @param options the options\r\n   */\n\n\n  function here(options) {\n    if (options.apiKey) {\n      return new HEREv2(options);\n    } else {\n      return new HERE(options);\n    }\n  }\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   * @param query the latitude/longitude string to parse\r\n   * @returns the parsed latitude/longitude\r\n   */\n\n\n  function parseLatLng(query) {\n    var match; // regex from https://github.com/openstreetmap/openstreetmap-website/blob/master/app/controllers/geocoder_controller.rb\n\n    if (match = query.match(/^([NS])\\s*(\\d{1,3}(?:\\.\\d*)?)\\W*([EW])\\s*(\\d{1,3}(?:\\.\\d*)?)$/)) {\n      // [NSEW] decimal degrees\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * +match[2], (/E/i.test(match[3]) ? 1 : -1) * +match[4]);\n    } else if (match = query.match(/^(\\d{1,3}(?:\\.\\d*)?)\\s*([NS])\\W*(\\d{1,3}(?:\\.\\d*)?)\\s*([EW])$/)) {\n      // decimal degrees [NSEW]\n      return L__namespace.latLng((/N/i.test(match[2]) ? 1 : -1) * +match[1], (/E/i.test(match[4]) ? 1 : -1) * +match[3]);\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?$/)) {\n      // [NSEW] degrees, decimal minutes\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60), (/E/i.test(match[4]) ? 1 : -1) * (+match[5] + +match[6] / 60));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([EW])$/)) {\n      // degrees, decimal minutes [NSEW]\n      return L__namespace.latLng((/N/i.test(match[3]) ? 1 : -1) * (+match[1] + +match[2] / 60), (/E/i.test(match[6]) ? 1 : -1) * (+match[4] + +match[5] / 60));\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?$/)) {\n      // [NSEW] degrees, minutes, decimal seconds\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60 + +match[4] / 3600), (/E/i.test(match[5]) ? 1 : -1) * (+match[6] + +match[7] / 60 + +match[8] / 3600));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\s*([EW])$/)) {\n      // degrees, minutes, decimal seconds [NSEW]\n      return L__namespace.latLng((/N/i.test(match[4]) ? 1 : -1) * (+match[1] + +match[2] / 60 + +match[3] / 3600), (/E/i.test(match[8]) ? 1 : -1) * (+match[5] + +match[6] / 60 + +match[7] / 3600));\n    } else if (match = query.match(/^\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*[\\s,]\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*$/)) {\n      return L__namespace.latLng(+match[1], +match[2]);\n    }\n  }\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   */\n\n\n  var LatLng = /*#__PURE__*/function () {\n    function LatLng(options) {\n      this.options = {\n        next: undefined,\n        sizeInMeters: 10000\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = LatLng.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var center = parseLatLng(query);\n\n      if (center) {\n        var results = [{\n          name: query,\n          center: center,\n          bbox: center.toBounds(this.options.sizeInMeters)\n        }];\n        cb.call(context, results);\n      } else if (this.options.next) {\n        this.options.next.geocode(query, cb, context);\n      }\n    };\n\n    return LatLng;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link LatLng}\r\n   * @param options the options\r\n   */\n\n\n  function latLng(options) {\n    return new LatLng(options);\n  }\n  /**\r\n   * Implementation of the [Mapbox Geocoding](https://www.mapbox.com/api-documentation/#geocoding)\r\n   */\n\n\n  var Mapbox = /*#__PURE__*/function () {\n    function Mapbox(options) {\n      this.options = {\n        serviceUrl: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Mapbox.prototype;\n\n    _proto._getProperties = function _getProperties(loc) {\n      var properties = {\n        text: loc.text,\n        address: loc.address\n      };\n\n      for (var j = 0; j < (loc.context || []).length; j++) {\n        var id = loc.context[j].id.split('.')[0];\n        properties[id] = loc.context[j].text; // Get country code when available\n\n        if (loc.context[j].short_code) {\n          properties['countryShortCode'] = loc.context[j].short_code;\n        }\n      }\n\n      return properties;\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        access_token: this.options.apiKey\n      });\n\n      if (params.proximity !== undefined && params.proximity.lat !== undefined && params.proximity.lng !== undefined) {\n        params.proximity = params.proximity.lng + ',' + params.proximity.lat;\n      }\n\n      getJSON(this.options.serviceUrl + encodeURIComponent(query) + '.json', params, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var url = this.options.serviceUrl + location.lng + ',' + location.lat + '.json';\n      var param = reverseParams(this.options, {\n        access_token: this.options.apiKey\n      });\n      getJSON(url, param, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this2._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Mapbox;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Mapbox}\r\n   * @param options the options\r\n   */\n\n\n  function mapbox(options) {\n    return new Mapbox(options);\n  }\n  /**\r\n   * Implementation of the [MapQuest Geocoding API](http://developer.mapquest.com/web/products/dev-services/geocoding-ws)\r\n   */\n\n\n  var MapQuest = /*#__PURE__*/function () {\n    function MapQuest(options) {\n      this.options = {\n        serviceUrl: 'https://www.mapquestapi.com/geocoding/v1'\n      };\n      L__namespace.Util.setOptions(this, options); // MapQuest seems to provide URI encoded API keys,\n      // so to avoid encoding them twice, we decode them here\n\n      this.options.apiKey = decodeURIComponent(this.options.apiKey);\n    }\n\n    var _proto = MapQuest.prototype;\n\n    _proto._formatName = function _formatName() {\n      return [].slice.call(arguments).filter(function (s) {\n        return !!s;\n      }).join(', ');\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        location: query,\n        limit: 5,\n        outFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/address', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        location: location.lat + ',' + location.lng,\n        outputFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    return MapQuest;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link MapQuest}\r\n   * @param options the options\r\n   */\n\n\n  function mapQuest(options) {\n    return new MapQuest(options);\n  }\n  /**\r\n   * Implementation of the [Neutrino API](https://www.neutrinoapi.com/api/geocode-address/)\r\n   */\n\n\n  var Neutrino = /*#__PURE__*/function () {\n    function Neutrino(options) {\n      this.options = {\n        userId: undefined,\n        apiKey: undefined,\n        serviceUrl: 'https://neutrinoapi.com/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    } // https://www.neutrinoapi.com/api/geocode-address/\n\n\n    var _proto = Neutrino.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        //get three words and make a dot based string\n        address: query.split(/\\s+/).join('.')\n      });\n      getJSON(this.options.serviceUrl + 'geocode-address', params, function (data) {\n        var results = [];\n\n        if (data.locations) {\n          data.geometry = data.locations[0];\n          var center = L__namespace.latLng(data.geometry['latitude'], data.geometry['longitude']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.geometry.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    } // https://www.neutrinoapi.com/api/geocode-reverse/\n    ;\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        latitude: location.lat,\n        longitude: location.lng\n      });\n      getJSON(this.options.serviceUrl + 'geocode-reverse', params, function (data) {\n        var results = [];\n\n        if (data.status.status == 200 && data.found) {\n          var center = L__namespace.latLng(location.lat, location.lng);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Neutrino;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Neutrino}\r\n   * @param options the options\r\n   */\n\n\n  function neutrino(options) {\n    return new Neutrino(options);\n  }\n  /**\r\n   * Implementation of the [Nominatim](https://wiki.openstreetmap.org/wiki/Nominatim) geocoder.\r\n   *\r\n   * This is the default geocoding service used by the control, unless otherwise specified in the options.\r\n   *\r\n   * Unless using your own Nominatim installation, please refer to the [Nominatim usage policy](https://operations.osmfoundation.org/policies/nominatim/).\r\n   */\n\n\n  var Nominatim = /*#__PURE__*/function () {\n    function Nominatim(options) {\n      this.options = {\n        serviceUrl: 'https://nominatim.openstreetmap.org/',\n        htmlTemplate: function htmlTemplate(r) {\n          var address = r.address;\n          var className;\n          var parts = [];\n\n          if (address.road || address.building) {\n            parts.push('{building} {road} {house_number}');\n          }\n\n          if (address.city || address.town || address.village || address.hamlet) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-detail' : '';\n            parts.push('<span class=\"' + className + '\">{postcode} {city} {town} {village} {hamlet}</span>');\n          }\n\n          if (address.state || address.country) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-context' : '';\n            parts.push('<span class=\"' + className + '\">{state} {country}</span>');\n          }\n\n          return template(parts.join('<br/>'), address);\n        }\n      };\n      L__namespace.Util.setOptions(this, options || {});\n    }\n\n    var _proto = Nominatim.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        q: query,\n        limit: 5,\n        format: 'json',\n        addressdetails: 1\n      });\n      getJSON(this.options.serviceUrl + 'search', params, function (data) {\n        var results = [];\n\n        for (var i = data.length - 1; i >= 0; i--) {\n          var bbox = data[i].boundingbox;\n\n          for (var j = 0; j < 4; j++) {\n            bbox[j] = +bbox[j];\n          }\n\n          results[i] = {\n            icon: data[i].icon,\n            name: data[i].display_name,\n            html: _this.options.htmlTemplate ? _this.options.htmlTemplate(data[i]) : undefined,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),\n            center: L__namespace.latLng(data[i].lat, data[i].lon),\n            properties: data[i]\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var params = reverseParams(this.options, {\n        lat: location.lat,\n        lon: location.lng,\n        zoom: Math.round(Math.log(scale / 256) / Math.log(2)),\n        addressdetails: 1,\n        format: 'json'\n      });\n      getJSON(this.options.serviceUrl + 'reverse', params, function (data) {\n        var result = [];\n\n        if (data && data.lat && data.lon) {\n          var center = L__namespace.latLng(data.lat, data.lon);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.display_name,\n            html: _this2.options.htmlTemplate ? _this2.options.htmlTemplate(data) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: data\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return Nominatim;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Nominatim}\r\n   * @param options the options\r\n   */\n\n\n  function nominatim(options) {\n    return new Nominatim(options);\n  }\n  /**\r\n   * Implementation of the [Plus codes](https://plus.codes/) (formerly OpenLocationCode) (requires [open-location-code](https://www.npmjs.com/package/open-location-code))\r\n   */\n\n\n  var OpenLocationCode = /*#__PURE__*/function () {\n    function OpenLocationCode(options) {\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenLocationCode.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      try {\n        var decoded = this.options.OpenLocationCode.decode(query);\n        var result = {\n          name: query,\n          center: L__namespace.latLng(decoded.latitudeCenter, decoded.longitudeCenter),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(decoded.latitudeLo, decoded.longitudeLo), L__namespace.latLng(decoded.latitudeHi, decoded.longitudeHi))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      try {\n        var code = this.options.OpenLocationCode.encode(location.lat, location.lng, this.options.codeLength);\n        var result = {\n          name: code,\n          center: L__namespace.latLng(location.lat, location.lng),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(location.lat, location.lng), L__namespace.latLng(location.lat, location.lng))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    return OpenLocationCode;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link OpenLocationCode}\r\n   * @param options the options\r\n   */\n\n\n  function openLocationCode(options) {\n    return new OpenLocationCode(options);\n  }\n  /**\r\n   * Implementation of the [OpenCage Data API](https://opencagedata.com/)\r\n   */\n\n\n  var OpenCage = /*#__PURE__*/function () {\n    function OpenCage(options) {\n      this.options = {\n        serviceUrl: 'https://api.opencagedata.com/geocode/v1/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenCage.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        q: [location.lat, location.lng].join(',')\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return OpenCage;\n  }();\n\n  function opencage(options) {\n    return new OpenCage(options);\n  }\n  /**\r\n   * Implementation of the [Pelias](https://pelias.io/), [geocode.earth](https://geocode.earth/) geocoder (formerly Mapzen Search)\r\n   */\n\n\n  var Pelias = /*#__PURE__*/function () {\n    function Pelias(options) {\n      this.options = {\n        serviceUrl: 'https://api.geocode.earth/v1'\n      };\n      this._lastSuggest = 0;\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Pelias.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/search', params, function (data) {\n        cb.call(context, _this._parseResults(data, 'bbox'));\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      var _this2 = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/autocomplete', params, function (data) {\n        if (data.geocoding.timestamp > _this2._lastSuggest) {\n          _this2._lastSuggest = data.geocoding.timestamp;\n          cb.call(context, _this2._parseResults(data, 'bbox'));\n        }\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this3 = this;\n\n      var params = reverseParams(this.options, {\n        api_key: this.options.apiKey,\n        'point.lat': location.lat,\n        'point.lon': location.lng\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, function (data) {\n        cb.call(context, _this3._parseResults(data, 'bounds'));\n      });\n    };\n\n    _proto._parseResults = function _parseResults(data, bboxname) {\n      var results = [];\n      L__namespace.geoJSON(data, {\n        pointToLayer: function pointToLayer(feature, latlng) {\n          return L__namespace.circleMarker(latlng);\n        },\n        onEachFeature: function onEachFeature(feature, layer) {\n          var result = {};\n          var bbox;\n          var center;\n\n          if (layer.getBounds) {\n            bbox = layer.getBounds();\n            center = bbox.getCenter();\n          } else if (layer.feature.bbox) {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(0, 2)), L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(2, 4)));\n          } else {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(center, center);\n          }\n\n          result.name = layer.feature.properties.label;\n          result.center = center;\n          result[bboxname] = bbox;\n          result.properties = layer.feature.properties;\n          results.push(result);\n        }\n      });\n      return results;\n    };\n\n    return Pelias;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Pelias}\r\n   * @param options the options\r\n   */\n\n\n  function pelias(options) {\n    return new Pelias(options);\n  }\n\n  var GeocodeEarth = Pelias;\n  var geocodeEarth = pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var Mapzen = Pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var mapzen = pelias;\n  /**\r\n   * Implementation of the [Openrouteservice](https://openrouteservice.org/dev/#/api-docs/geocode) geocoder\r\n   */\n\n  var Openrouteservice = /*#__PURE__*/function (_Pelias) {\n    _inheritsLoose(Openrouteservice, _Pelias);\n\n    function Openrouteservice(options) {\n      return _Pelias.call(this, L__namespace.Util.extend({\n        serviceUrl: 'https://api.openrouteservice.org/geocode'\n      }, options)) || this;\n    }\n\n    return Openrouteservice;\n  }(Pelias);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Openrouteservice}\r\n   * @param options the options\r\n   */\n\n\n  function openrouteservice(options) {\n    return new Openrouteservice(options);\n  }\n  /**\r\n   * Implementation of the [Photon](http://photon.komoot.de/) geocoder\r\n   */\n\n\n  var Photon = /*#__PURE__*/function () {\n    function Photon(options) {\n      this.options = {\n        serviceUrl: 'https://photon.komoot.io/api/',\n        reverseUrl: 'https://photon.komoot.io/reverse/',\n        nameProperties: ['name', 'street', 'suburb', 'hamlet', 'town', 'city', 'state', 'country']\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Photon.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(latLng, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        lat: latLng.lat,\n        lon: latLng.lng\n      });\n      getJSON(this.options.reverseUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto._decodeFeatures = function _decodeFeatures(data) {\n      var results = [];\n\n      if (data && data.features) {\n        for (var i = 0; i < data.features.length; i++) {\n          var f = data.features[i];\n          var c = f.geometry.coordinates;\n          var center = L__namespace.latLng(c[1], c[0]);\n          var extent = f.properties.extent;\n          var bbox = extent ? L__namespace.latLngBounds([extent[1], extent[0]], [extent[3], extent[2]]) : L__namespace.latLngBounds(center, center);\n          results.push({\n            name: this._decodeFeatureName(f),\n            html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: f.properties\n          });\n        }\n      }\n\n      return results;\n    };\n\n    _proto._decodeFeatureName = function _decodeFeatureName(f) {\n      return (this.options.nameProperties || []).map(function (p) {\n        return f.properties[p];\n      }).filter(function (v) {\n        return !!v;\n      }).join(', ');\n    };\n\n    return Photon;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Photon}\r\n   * @param options the options\r\n   */\n\n\n  function photon(options) {\n    return new Photon(options);\n  }\n  /**\r\n   * Implementation of the What3Words service\r\n   */\n\n\n  var What3Words = /*#__PURE__*/function () {\n    function What3Words(options) {\n      this.options = {\n        serviceUrl: 'https://api.what3words.com/v2/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = What3Words.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      //get three words and make a dot based string\n      getJSON(this.options.serviceUrl + 'forward', geocodingParams(this.options, {\n        key: this.options.apiKey,\n        addr: query.split(/\\s+/).join('.')\n      }), function (data) {\n        var results = [];\n\n        if (data.geometry) {\n          var latLng = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var latLngBounds = L__namespace.latLngBounds(latLng, latLng);\n          results[0] = {\n            name: data.words,\n            bbox: latLngBounds,\n            center: latLng\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      getJSON(this.options.serviceUrl + 'reverse', reverseParams(this.options, {\n        key: this.options.apiKey,\n        coords: [location.lat, location.lng].join(',')\n      }), function (data) {\n        var results = [];\n\n        if (data.status.status == 200) {\n          var center = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.words,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return What3Words;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link What3Words}\r\n   * @param options the options\r\n   */\n\n\n  function what3words(options) {\n    return new What3Words(options);\n  }\n\n  var geocoders = {\n    __proto__: null,\n    geocodingParams: geocodingParams,\n    reverseParams: reverseParams,\n    ArcGis: ArcGis,\n    arcgis: arcgis,\n    Bing: Bing,\n    bing: bing,\n    Google: Google,\n    google: google,\n    HERE: HERE,\n    HEREv2: HEREv2,\n    here: here,\n    parseLatLng: parseLatLng,\n    LatLng: LatLng,\n    latLng: latLng,\n    Mapbox: Mapbox,\n    mapbox: mapbox,\n    MapQuest: MapQuest,\n    mapQuest: mapQuest,\n    Neutrino: Neutrino,\n    neutrino: neutrino,\n    Nominatim: Nominatim,\n    nominatim: nominatim,\n    OpenLocationCode: OpenLocationCode,\n    openLocationCode: openLocationCode,\n    OpenCage: OpenCage,\n    opencage: opencage,\n    Pelias: Pelias,\n    pelias: pelias,\n    GeocodeEarth: GeocodeEarth,\n    geocodeEarth: geocodeEarth,\n    Mapzen: Mapzen,\n    mapzen: mapzen,\n    Openrouteservice: Openrouteservice,\n    openrouteservice: openrouteservice,\n    Photon: Photon,\n    photon: photon,\n    What3Words: What3Words,\n    what3words: what3words\n  };\n  /**\r\n   * Leaflet mixins https://leafletjs.com/reference-1.7.1.html#class-includes\r\n   * for TypeScript https://www.typescriptlang.org/docs/handbook/mixins.html\r\n   * @internal\r\n   */\n\n  var EventedControl = // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function EventedControl() {// empty\n  };\n\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Control.prototype);\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Evented.prototype);\n  /**\r\n   * This is the geocoder control. It works like any other [Leaflet control](https://leafletjs.com/reference.html#control), and is added to the map.\r\n   */\n\n  var GeocoderControl = /*#__PURE__*/function (_EventedControl) {\n    _inheritsLoose(GeocoderControl, _EventedControl);\n    /**\r\n     * Instantiates a geocoder control (to be invoked using `new`)\r\n     * @param options the options\r\n     */\n\n\n    function GeocoderControl(options) {\n      var _this;\n\n      _this = _EventedControl.call(this, options) || this;\n      _this.options = {\n        showUniqueResult: true,\n        showResultIcons: false,\n        collapsed: true,\n        expand: 'touch',\n        position: 'topright',\n        placeholder: 'Search...',\n        errorMessage: 'Nothing found.',\n        iconLabel: 'Initiate a new search',\n        query: '',\n        queryMinLength: 1,\n        suggestMinLength: 3,\n        suggestTimeout: 250,\n        defaultMarkGeocode: true\n      };\n      _this._requestCount = 0;\n      L__namespace.Util.setOptions(_assertThisInitialized(_this), options);\n\n      if (!_this.options.geocoder) {\n        _this.options.geocoder = new Nominatim();\n      }\n\n      return _this;\n    }\n\n    var _proto = GeocoderControl.prototype;\n\n    _proto.addThrobberClass = function addThrobberClass() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');\n    };\n\n    _proto.removeThrobberClass = function removeThrobberClass() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');\n    }\n    /**\r\n     * Returns the container DOM element for the control and add listeners on relevant map events.\r\n     * @param map the map instance\r\n     * @see https://leafletjs.com/reference.html#control-onadd\r\n     */\n    ;\n\n    _proto.onAdd = function onAdd(map) {\n      var _this2 = this;\n\n      var className = 'leaflet-control-geocoder';\n      var container = L__namespace.DomUtil.create('div', className + ' leaflet-bar');\n      var icon = L__namespace.DomUtil.create('button', className + '-icon', container);\n      var form = this._form = L__namespace.DomUtil.create('div', className + '-form', container);\n      this._map = map;\n      this._container = container;\n      icon.innerHTML = '&nbsp;';\n      icon.type = 'button';\n      icon.setAttribute('aria-label', this.options.iconLabel);\n      var input = this._input = L__namespace.DomUtil.create('input', '', form);\n      input.type = 'text';\n      input.value = this.options.query;\n      input.placeholder = this.options.placeholder;\n      L__namespace.DomEvent.disableClickPropagation(input);\n      this._errorElement = L__namespace.DomUtil.create('div', className + '-form-no-error', container);\n      this._errorElement.innerHTML = this.options.errorMessage;\n      this._alts = L__namespace.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized', container);\n      L__namespace.DomEvent.disableClickPropagation(this._alts);\n      L__namespace.DomEvent.addListener(input, 'keydown', this._keydown, this);\n\n      if (this.options.geocoder.suggest) {\n        L__namespace.DomEvent.addListener(input, 'input', this._change, this);\n      }\n\n      L__namespace.DomEvent.addListener(input, 'blur', function () {\n        if (_this2.options.collapsed && !_this2._preventBlurCollapse) {\n          _this2._collapse();\n        }\n\n        _this2._preventBlurCollapse = false;\n      });\n\n      if (this.options.collapsed) {\n        if (this.options.expand === 'click') {\n          L__namespace.DomEvent.addListener(container, 'click', function (e) {\n            if (e.button === 0 && e.detail !== 2) {\n              _this2._toggle();\n            }\n          });\n        } else if (this.options.expand === 'touch') {\n          L__namespace.DomEvent.addListener(container, L__namespace.Browser.touch ? 'touchstart mousedown' : 'mousedown', function (e) {\n            _this2._toggle();\n\n            e.preventDefault(); // mobile: clicking focuses the icon, so UI expands and immediately collapses\n\n            e.stopPropagation();\n          }, this);\n        } else {\n          L__namespace.DomEvent.addListener(container, 'mouseover', this._expand, this);\n          L__namespace.DomEvent.addListener(container, 'mouseout', this._collapse, this);\n\n          this._map.on('movestart', this._collapse, this);\n        }\n      } else {\n        this._expand();\n\n        if (L__namespace.Browser.touch) {\n          L__namespace.DomEvent.addListener(container, 'touchstart', function () {\n            return _this2._geocode();\n          });\n        } else {\n          L__namespace.DomEvent.addListener(container, 'click', function () {\n            return _this2._geocode();\n          });\n        }\n      }\n\n      if (this.options.defaultMarkGeocode) {\n        this.on('markgeocode', this.markGeocode, this);\n      }\n\n      this.on('startgeocode', this.addThrobberClass, this);\n      this.on('finishgeocode', this.removeThrobberClass, this);\n      this.on('startsuggest', this.addThrobberClass, this);\n      this.on('finishsuggest', this.removeThrobberClass, this);\n      L__namespace.DomEvent.disableClickPropagation(container);\n      return container;\n    }\n    /**\r\n     * Sets the query string on the text input\r\n     * @param string the query string\r\n     */\n    ;\n\n    _proto.setQuery = function setQuery(string) {\n      this._input.value = string;\n      return this;\n    };\n\n    _proto._geocodeResult = function _geocodeResult(results, suggest) {\n      if (!suggest && this.options.showUniqueResult && results.length === 1) {\n        this._geocodeResultSelected(results[0]);\n      } else if (results.length > 0) {\n        this._alts.innerHTML = '';\n        this._results = results;\n        L__namespace.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-open');\n\n        for (var i = 0; i < results.length; i++) {\n          this._alts.appendChild(this._createAlt(results[i], i));\n        }\n      } else {\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-error');\n        L__namespace.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');\n      }\n    }\n    /**\r\n     * Marks a geocoding result on the map\r\n     * @param result the geocoding result\r\n     */\n    ;\n\n    _proto.markGeocode = function markGeocode(event) {\n      var result = event.geocode;\n\n      this._map.fitBounds(result.bbox);\n\n      if (this._geocodeMarker) {\n        this._map.removeLayer(this._geocodeMarker);\n      }\n\n      this._geocodeMarker = new L__namespace.Marker(result.center).bindPopup(result.html || result.name).addTo(this._map).openPopup();\n      return this;\n    };\n\n    _proto._geocode = function _geocode(suggest) {\n      var _this3 = this;\n\n      var value = this._input.value;\n\n      if (!suggest && value.length < this.options.queryMinLength) {\n        return;\n      }\n\n      var requestCount = ++this._requestCount;\n\n      var cb = function cb(results) {\n        if (requestCount === _this3._requestCount) {\n          var _event = {\n            input: value,\n            results: results\n          };\n\n          _this3.fire(suggest ? 'finishsuggest' : 'finishgeocode', _event);\n\n          _this3._geocodeResult(results, suggest);\n        }\n      };\n\n      this._lastGeocode = value;\n\n      if (!suggest) {\n        this._clearResults();\n      }\n\n      var event = {\n        input: value\n      };\n      this.fire(suggest ? 'startsuggest' : 'startgeocode', event);\n\n      if (suggest) {\n        this.options.geocoder.suggest(value, cb);\n      } else {\n        this.options.geocoder.geocode(value, cb);\n      }\n    };\n\n    _proto._geocodeResultSelected = function _geocodeResultSelected(geocode) {\n      var event = {\n        geocode: geocode\n      };\n      this.fire('markgeocode', event);\n    };\n\n    _proto._toggle = function _toggle() {\n      if (L__namespace.DomUtil.hasClass(this._container, 'leaflet-control-geocoder-expanded')) {\n        this._collapse();\n      } else {\n        this._expand();\n      }\n    };\n\n    _proto._expand = function _expand() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');\n\n      this._input.select();\n\n      this.fire('expand');\n    };\n\n    _proto._collapse = function _collapse() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-expanded');\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n\n      this._input.blur(); // mobile: keyboard shouldn't stay expanded\n\n\n      this.fire('collapse');\n    };\n\n    _proto._clearResults = function _clearResults() {\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      this._selection = null;\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n    };\n\n    _proto._createAlt = function _createAlt(result, index) {\n      var _this4 = this;\n\n      var li = L__namespace.DomUtil.create('li', ''),\n          a = L__namespace.DomUtil.create('a', '', li),\n          icon = this.options.showResultIcons && result.icon ? L__namespace.DomUtil.create('img', '', a) : null,\n          text = result.html ? undefined : document.createTextNode(result.name),\n          mouseDownHandler = function mouseDownHandler(e) {\n        // In some browsers, a click will fire on the map if the control is\n        // collapsed directly after mousedown. To work around this, we\n        // wait until the click is completed, and _then_ collapse the\n        // control. Messy, but this is the workaround I could come up with\n        // for #142.\n        _this4._preventBlurCollapse = true;\n        L__namespace.DomEvent.stop(e);\n\n        _this4._geocodeResultSelected(result);\n\n        L__namespace.DomEvent.on(li, 'click touchend', function () {\n          if (_this4.options.collapsed) {\n            _this4._collapse();\n          } else {\n            _this4._clearResults();\n          }\n        });\n      };\n\n      if (icon) {\n        icon.src = result.icon;\n      }\n\n      li.setAttribute('data-result-index', String(index));\n\n      if (result.html) {\n        a.innerHTML = a.innerHTML + result.html;\n      } else if (text) {\n        a.appendChild(text);\n      } // Use mousedown and not click, since click will fire _after_ blur,\n      // causing the control to have collapsed and removed the items\n      // before the click can fire.\n\n\n      L__namespace.DomEvent.addListener(li, 'mousedown touchstart', mouseDownHandler, this);\n      return li;\n    };\n\n    _proto._keydown = function _keydown(e) {\n      var _this5 = this;\n\n      var select = function select(dir) {\n        if (_this5._selection) {\n          L__namespace.DomUtil.removeClass(_this5._selection, 'leaflet-control-geocoder-selected');\n          _this5._selection = _this5._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];\n        }\n\n        if (!_this5._selection) {\n          _this5._selection = _this5._alts[dir > 0 ? 'firstChild' : 'lastChild'];\n        }\n\n        if (_this5._selection) {\n          L__namespace.DomUtil.addClass(_this5._selection, 'leaflet-control-geocoder-selected');\n        }\n      };\n\n      switch (e.keyCode) {\n        // Escape\n        case 27:\n          if (this.options.collapsed) {\n            this._collapse();\n          } else {\n            this._clearResults();\n          }\n\n          break;\n        // Up\n\n        case 38:\n          select(-1);\n          break;\n        // Up\n\n        case 40:\n          select(1);\n          break;\n        // Enter\n\n        case 13:\n          if (this._selection) {\n            var index = parseInt(this._selection.getAttribute('data-result-index'), 10);\n\n            this._geocodeResultSelected(this._results[index]);\n\n            this._clearResults();\n          } else {\n            this._geocode();\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      L__namespace.DomEvent.preventDefault(e);\n    };\n\n    _proto._change = function _change() {\n      var _this6 = this;\n\n      var v = this._input.value;\n\n      if (v !== this._lastGeocode) {\n        clearTimeout(this._suggestTimeout);\n\n        if (v.length >= this.options.suggestMinLength) {\n          this._suggestTimeout = setTimeout(function () {\n            return _this6._geocode(true);\n          }, this.options.suggestTimeout);\n        } else {\n          this._clearResults();\n        }\n      }\n    };\n\n    return GeocoderControl;\n  }(EventedControl);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link GeocoderControl}\r\n   * @param options the options\r\n   */\n\n\n  function geocoder(options) {\n    return new GeocoderControl(options);\n  }\n  /* @preserve\r\n   * Leaflet Control Geocoder\r\n   * https://github.com/perliedman/leaflet-control-geocoder\r\n   *\r\n   * Copyright (c) 2012 sa3m (https://github.com/sa3m)\r\n   * Copyright (c) 2018 Per Liedman\r\n   * All rights reserved.\r\n   */\n\n\n  L__namespace.Util.extend(GeocoderControl, geocoders);\n  L__namespace.Util.extend(L__namespace.Control, {\n    Geocoder: GeocoderControl,\n    geocoder: geocoder\n  });\n  exports.Geocoder = GeocoderControl;\n  exports.default = GeocoderControl;\n  exports.geocoder = geocoder;\n  exports.geocoders = geocoders;\n  return exports;\n}({}, L);","map":null,"metadata":{},"sourceType":"script"}