{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { BaseLoggger, Html5QrcodeResultFactory, Html5QrcodeErrorFactory, Html5QrcodeSupportedFormats, isValidHtml5QrcodeSupportedFormats, Html5QrcodeConstants, isNullOrUndefined } from \"./core\";\nimport { Html5QrcodeStrings } from \"./strings\";\nimport { VideoConstraintsUtil } from \"./utils\";\nimport { Html5QrcodeShim } from \"./code-decoder\";\nimport { ExperimentalFeaturesConfigFactory } from \"./experimental-features\";\nimport { StateManagerFactory, Html5QrcodeScannerState } from \"./state-manager\";\n\nvar Constants = function (_super) {\n  __extends(Constants, _super);\n\n  function Constants() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Constants.DEFAULT_WIDTH = 300;\n  Constants.DEFAULT_WIDTH_OFFSET = 2;\n  Constants.FILE_SCAN_MIN_HEIGHT = 300;\n  Constants.MIN_QR_BOX_SIZE = 50;\n  Constants.SHADED_LEFT = 1;\n  Constants.SHADED_RIGHT = 2;\n  Constants.SHADED_TOP = 3;\n  Constants.SHADED_BOTTOM = 4;\n  Constants.SHADED_REGION_ELEMENT_ID = \"qr-shaded-region\";\n  Constants.VERBOSE = false;\n  Constants.BORDER_SHADER_DEFAULT_COLOR = \"#ffffff\";\n  Constants.BORDER_SHADER_MATCH_COLOR = \"rgb(90, 193, 56)\";\n  return Constants;\n}(Html5QrcodeConstants);\n\nvar InternalHtml5QrcodeConfig = function () {\n  function InternalHtml5QrcodeConfig(config, logger) {\n    this.logger = logger;\n    this.fps = Constants.SCAN_DEFAULT_FPS;\n\n    if (!config) {\n      this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;\n    } else {\n      if (config.fps) {\n        this.fps = config.fps;\n      }\n\n      this.disableFlip = config.disableFlip === true;\n      this.qrbox = config.qrbox;\n      this.aspectRatio = config.aspectRatio;\n      this.videoConstraints = config.videoConstraints;\n    }\n  }\n\n  InternalHtml5QrcodeConfig.prototype.isMediaStreamConstraintsValid = function () {\n    if (!this.videoConstraints) {\n      this.logger.logError(\"Empty videoConstraints\", true);\n      return false;\n    }\n\n    return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);\n  };\n\n  InternalHtml5QrcodeConfig.prototype.isShadedBoxEnabled = function () {\n    return !isNullOrUndefined(this.qrbox);\n  };\n\n  InternalHtml5QrcodeConfig.create = function (config, logger) {\n    return new InternalHtml5QrcodeConfig(config, logger);\n  };\n\n  return InternalHtml5QrcodeConfig;\n}();\n\nvar Html5Qrcode = function () {\n  function Html5Qrcode(elementId, configOrVerbosityFlag) {\n    this.element = null;\n    this.canvasElement = null;\n    this.scannerPausedUiElement = null;\n    this.hasBorderShaders = null;\n    this.borderShaders = null;\n    this.qrMatch = null;\n    this.videoElement = null;\n    this.localMediaStream = null;\n    this.qrRegion = null;\n    this.context = null;\n    this.lastScanImageFile = null;\n    this.isScanning = false;\n\n    if (!document.getElementById(elementId)) {\n      throw \"HTML Element with id=\" + elementId + \" not found\";\n    }\n\n    this.elementId = elementId;\n    this.verbose = false;\n    var experimentalFeatureConfig;\n\n    if (typeof configOrVerbosityFlag == \"boolean\") {\n      this.verbose = configOrVerbosityFlag === true;\n    } else if (configOrVerbosityFlag) {\n      this.verbose = configOrVerbosityFlag.verbose === true;\n      experimentalFeatureConfig = configOrVerbosityFlag.experimentalFeatures;\n    }\n\n    this.logger = new BaseLoggger(this.verbose);\n    this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.verbose, this.logger, ExperimentalFeaturesConfigFactory.createExperimentalFeaturesConfig(experimentalFeatureConfig));\n    this.foreverScanTimeout;\n    this.localMediaStream;\n    this.shouldScan = true;\n    this.stateManagerProxy = StateManagerFactory.create();\n  }\n\n  Html5Qrcode.prototype.start = function (cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {\n    if (!cameraIdOrConfig) {\n      throw \"cameraIdOrConfig is required\";\n    }\n\n    if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != \"function\") {\n      throw \"qrCodeSuccessCallback is required and should be a function.\";\n    }\n\n    if (!qrCodeErrorCallback) {\n      qrCodeErrorCallback = this.verbose ? this.logger.log : function () {};\n    }\n\n    var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);\n    this.clearElement();\n    var videoConstraintsAvailableAndValid = false;\n\n    if (internalConfig.videoConstraints) {\n      if (!internalConfig.isMediaStreamConstraintsValid()) {\n        this.logger.logError(\"'videoConstraints' is not valid 'MediaStreamConstraints, \" + \"it will be ignored.'\", true);\n      } else {\n        videoConstraintsAvailableAndValid = true;\n      }\n    }\n\n    var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;\n    var isShadedBoxEnabled = internalConfig.isShadedBoxEnabled();\n    var element = document.getElementById(this.elementId);\n    var rootElementWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;\n    element.style.position = \"relative\";\n    this.shouldScan = true;\n    this.element = element;\n    var $this = this;\n    var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);\n    return new Promise(function (resolve, reject) {\n      var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);\n\n      if (!videoConstraints) {\n        toScanningStateChangeTransaction.cancel();\n        reject(\"videoConstraints should be defined\");\n        return;\n      }\n\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n        navigator.mediaDevices.getUserMedia({\n          audio: false,\n          video: videoConstraints\n        }).then(function (stream) {\n          $this.onMediaStreamReceived(stream, internalConfig, areVideoConstraintsEnabled, rootElementWidth, qrCodeSuccessCallback, qrCodeErrorCallback).then(function (_) {\n            toScanningStateChangeTransaction.execute();\n            $this.isScanning = true;\n            resolve(null);\n          }).catch(function (error) {\n            toScanningStateChangeTransaction.cancel();\n            reject(error);\n          });\n        }).catch(function (error) {\n          toScanningStateChangeTransaction.cancel();\n          reject(Html5QrcodeStrings.errorGettingUserMedia(error));\n        });\n      } else {\n        toScanningStateChangeTransaction.cancel();\n        reject(Html5QrcodeStrings.cameraStreamingNotSupported());\n      }\n    });\n  };\n\n  Html5Qrcode.prototype.pause = function (shouldPauseVideo) {\n    if (!this.stateManagerProxy.isStrictlyScanning()) {\n      throw \"Cannot pause, scanner is not scanning.\";\n    }\n\n    this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);\n    this.showPausedState();\n\n    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {\n      shouldPauseVideo = false;\n    }\n\n    if (shouldPauseVideo && this.videoElement) {\n      this.videoElement.pause();\n    }\n  };\n\n  Html5Qrcode.prototype.resume = function () {\n    if (!this.stateManagerProxy.isPaused()) {\n      throw \"Cannot result, scanner is not paused.\";\n    }\n\n    if (!this.videoElement) {\n      throw \"VideoElement doesn't exist while trying resume()\";\n    }\n\n    var $this = this;\n\n    var transitionToScanning = function transitionToScanning() {\n      $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);\n      $this.hidePausedState();\n    };\n\n    var isVideoPaused = this.videoElement.paused;\n\n    if (!isVideoPaused) {\n      transitionToScanning();\n      return;\n    }\n\n    var onVideoResume = function onVideoResume() {\n      var _a;\n\n      setTimeout(transitionToScanning, 200);\n      (_a = $this.videoElement) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"playing\", onVideoResume);\n    };\n\n    this.videoElement.addEventListener(\"playing\", onVideoResume);\n    this.videoElement.play();\n  };\n\n  Html5Qrcode.prototype.getState = function () {\n    return this.stateManagerProxy.getState();\n  };\n\n  Html5Qrcode.prototype.stop = function () {\n    var _this = this;\n\n    if (!this.stateManagerProxy.isScanning()) {\n      throw \"Cannot stop, scanner is not running or paused.\";\n    }\n\n    var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);\n    this.shouldScan = false;\n\n    if (this.foreverScanTimeout) {\n      clearTimeout(this.foreverScanTimeout);\n    }\n\n    var removeQrRegion = function removeQrRegion() {\n      if (!_this.element) {\n        return;\n      }\n\n      var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);\n\n      if (childElement) {\n        _this.element.removeChild(childElement);\n      }\n    };\n\n    return new Promise(function (resolve, _) {\n      var onAllTracksClosed = function onAllTracksClosed() {\n        _this.localMediaStream = null;\n\n        if (_this.element) {\n          _this.element.removeChild(_this.videoElement);\n\n          _this.element.removeChild(_this.canvasElement);\n        }\n\n        removeQrRegion();\n\n        if (_this.qrRegion) {\n          _this.qrRegion = null;\n        }\n\n        if (_this.context) {\n          _this.context = null;\n        }\n\n        toStoppedStateTransaction.execute();\n\n        _this.hidePausedState();\n\n        _this.isScanning = false;\n        resolve();\n      };\n\n      if (!_this.localMediaStream) {\n        onAllTracksClosed();\n      }\n\n      var tracksToClose = _this.localMediaStream.getVideoTracks().length;\n\n      var tracksClosed = 0;\n\n      _this.localMediaStream.getVideoTracks().forEach(function (videoTrack) {\n        _this.localMediaStream.removeTrack(videoTrack);\n\n        videoTrack.stop();\n        ++tracksClosed;\n\n        if (tracksClosed >= tracksToClose) {\n          onAllTracksClosed();\n        }\n      });\n    });\n  };\n\n  Html5Qrcode.prototype.scanFile = function (imageFile, showImage) {\n    return this.scanFileV2(imageFile, showImage).then(function (html5qrcodeResult) {\n      return html5qrcodeResult.decodedText;\n    });\n  };\n\n  Html5Qrcode.prototype.scanFileV2 = function (imageFile, showImage) {\n    var _this = this;\n\n    if (!imageFile || !(imageFile instanceof File)) {\n      throw \"imageFile argument is mandatory and should be instance \" + \"of File. Use 'event.target.files[0]'.\";\n    }\n\n    if (isNullOrUndefined(showImage)) {\n      showImage = true;\n    }\n\n    if (!this.stateManagerProxy.canScanFile()) {\n      throw \"Cannot start file scan - ongoing camera scan\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      _this.possiblyCloseLastScanImageFile();\n\n      _this.clearElement();\n\n      _this.lastScanImageFile = URL.createObjectURL(imageFile);\n      var inputImage = new Image();\n\n      inputImage.onload = function () {\n        var imageWidth = inputImage.width;\n        var imageHeight = inputImage.height;\n        var element = document.getElementById(_this.elementId);\n        var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;\n        var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);\n\n        var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n\n        if (showImage) {\n          var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, \"qr-canvas-visible\");\n\n          visibleCanvas.style.display = \"inline-block\";\n          element.appendChild(visibleCanvas);\n          var context_1 = visibleCanvas.getContext(\"2d\");\n\n          if (!context_1) {\n            throw \"Unable to get 2d context from canvas\";\n          }\n\n          context_1.canvas.width = containerWidth;\n          context_1.canvas.height = containerHeight;\n          context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);\n        }\n\n        var hiddenCanvas = _this.createCanvasElement(config.width, config.height);\n\n        element.appendChild(hiddenCanvas);\n        var context = hiddenCanvas.getContext(\"2d\");\n\n        if (!context) {\n          throw \"Unable to get 2d context from canvas\";\n        }\n\n        context.canvas.width = config.width;\n        context.canvas.height = config.height;\n        context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, 0, 0, config.width, config.height);\n\n        try {\n          _this.qrcode.decodeAsync(hiddenCanvas).then(function (result) {\n            resolve(Html5QrcodeResultFactory.createFromQrcodeResult(result));\n          }).catch(reject);\n        } catch (exception) {\n          reject(\"QR code parse error, error = \" + exception);\n        }\n      };\n\n      inputImage.onerror = reject;\n      inputImage.onabort = reject;\n      inputImage.onstalled = reject;\n      inputImage.onsuspend = reject;\n      inputImage.src = URL.createObjectURL(imageFile);\n    });\n  };\n\n  Html5Qrcode.prototype.clear = function () {\n    this.clearElement();\n  };\n\n  Html5Qrcode.getCameras = function () {\n    if (navigator.mediaDevices) {\n      return Html5Qrcode.getCamerasFromMediaDevices();\n    }\n\n    var mst = MediaStreamTrack;\n\n    if (MediaStreamTrack && mst.getSources) {\n      return Html5Qrcode.getCamerasFromMediaStreamTrack();\n    }\n\n    var isHttpsOrLocalhost = function isHttpsOrLocalhost() {\n      if (location.protocol === \"https:\") {\n        return true;\n      }\n\n      var host = location.host.split(\":\")[0];\n      return host === \"127.0.0.1\" || host === \"localhost\";\n    };\n\n    var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();\n\n    if (!isHttpsOrLocalhost()) {\n      errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();\n    }\n\n    return Promise.reject(errorMessage);\n  };\n\n  Html5Qrcode.prototype.getRunningTrackCapabilities = function () {\n    if (this.localMediaStream == null) {\n      throw \"Scanning is not in running state, call this API only when\" + \" QR code scanning using camera is in running state.\";\n    }\n\n    if (this.localMediaStream.getVideoTracks().length === 0) {\n      throw \"No video tracks found\";\n    }\n\n    var videoTrack = this.localMediaStream.getVideoTracks()[0];\n    return videoTrack.getCapabilities();\n  };\n\n  Html5Qrcode.prototype.applyVideoConstraints = function (videoConstaints) {\n    var _this = this;\n\n    if (!videoConstaints) {\n      throw \"videoConstaints is required argument.\";\n    } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {\n      throw \"invalid videoConstaints passed, check logs for more details\";\n    }\n\n    if (this.localMediaStream === null) {\n      throw \"Scanning is not in running state, call this API only when\" + \" QR code scanning using camera is in running state.\";\n    }\n\n    if (this.localMediaStream.getVideoTracks().length === 0) {\n      throw \"No video tracks found\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (\"aspectRatio\" in videoConstaints) {\n        reject(\"Chaning 'aspectRatio' in run-time is not yet \" + \"supported.\");\n        return;\n      }\n\n      var videoTrack = _this.localMediaStream.getVideoTracks()[0];\n\n      videoTrack.applyConstraints(videoConstaints).then(function (_) {\n        resolve(_);\n      }).catch(function (error) {\n        reject(error);\n      });\n    });\n  };\n\n  Html5Qrcode.getCamerasFromMediaDevices = function () {\n    return new Promise(function (resolve, reject) {\n      navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: true\n      }).then(function (stream) {\n        var closeActiveStreams = function closeActiveStreams(stream) {\n          var tracks = stream.getVideoTracks();\n\n          for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {\n            var track = tracks_1[_i];\n            track.enabled = false;\n            track.stop();\n            stream.removeTrack(track);\n          }\n        };\n\n        navigator.mediaDevices.enumerateDevices().then(function (devices) {\n          var results = [];\n\n          for (var _i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n            var device = devices_1[_i];\n\n            if (device.kind === \"videoinput\") {\n              results.push({\n                id: device.deviceId,\n                label: device.label\n              });\n            }\n          }\n\n          closeActiveStreams(stream);\n          resolve(results);\n        }).catch(function (err) {\n          reject(err.name + \" : \" + err.message);\n        });\n      }).catch(function (err) {\n        reject(err.name + \" : \" + err.message);\n      });\n    });\n  };\n\n  Html5Qrcode.getCamerasFromMediaStreamTrack = function () {\n    return new Promise(function (resolve, _) {\n      var callback = function callback(sourceInfos) {\n        var results = [];\n\n        for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {\n          var sourceInfo = sourceInfos_1[_i];\n\n          if (sourceInfo.kind === \"video\") {\n            results.push({\n              id: sourceInfo.id,\n              label: sourceInfo.label\n            });\n          }\n        }\n\n        resolve(results);\n      };\n\n      var mst = MediaStreamTrack;\n      mst.getSources(callback);\n    });\n  };\n\n  Html5Qrcode.prototype.getSupportedFormats = function (configOrVerbosityFlag) {\n    var allFormats = [Html5QrcodeSupportedFormats.QR_CODE, Html5QrcodeSupportedFormats.AZTEC, Html5QrcodeSupportedFormats.CODABAR, Html5QrcodeSupportedFormats.CODE_39, Html5QrcodeSupportedFormats.CODE_93, Html5QrcodeSupportedFormats.CODE_128, Html5QrcodeSupportedFormats.DATA_MATRIX, Html5QrcodeSupportedFormats.MAXICODE, Html5QrcodeSupportedFormats.ITF, Html5QrcodeSupportedFormats.EAN_13, Html5QrcodeSupportedFormats.EAN_8, Html5QrcodeSupportedFormats.PDF_417, Html5QrcodeSupportedFormats.RSS_14, Html5QrcodeSupportedFormats.RSS_EXPANDED, Html5QrcodeSupportedFormats.UPC_A, Html5QrcodeSupportedFormats.UPC_E, Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION];\n\n    if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == \"boolean\") {\n      return allFormats;\n    }\n\n    if (!configOrVerbosityFlag.formatsToSupport) {\n      return allFormats;\n    }\n\n    if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {\n      throw \"configOrVerbosityFlag.formatsToSupport should be undefined \" + \"or an array.\";\n    }\n\n    if (configOrVerbosityFlag.formatsToSupport.length === 0) {\n      throw \"Atleast 1 formatsToSupport is needed.\";\n    }\n\n    var supportedFormats = [];\n\n    for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {\n      var format = _a[_i];\n\n      if (isValidHtml5QrcodeSupportedFormats(format)) {\n        supportedFormats.push(format);\n      } else {\n        this.logger.warn(\"Invalid format: \" + format + \" passed in config, ignoring.\");\n      }\n    }\n\n    if (supportedFormats.length === 0) {\n      throw \"None of formatsToSupport match supported values.\";\n    }\n\n    return supportedFormats;\n  };\n\n  Html5Qrcode.prototype.validateQrboxSize = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n    var _this = this;\n\n    var qrboxSize = internalConfig.qrbox;\n    this.validateQrboxConfig(qrboxSize);\n    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n\n    var validateMinSize = function validateMinSize(size) {\n      if (size < Constants.MIN_QR_BOX_SIZE) {\n        throw \"minimum size of 'config.qrbox' dimension value is\" + (\" \" + Constants.MIN_QR_BOX_SIZE + \"px.\");\n      }\n    };\n\n    var correctWidthBasedOnRootElementSize = function correctWidthBasedOnRootElementSize(configWidth) {\n      if (configWidth > viewfinderWidth) {\n        _this.logger.warn(\"`qrbox.width` or `qrbox` is larger than the\" + \" width of the root element. The width will be truncated\" + \" to the width of root element.\");\n\n        configWidth = viewfinderWidth;\n      }\n\n      return configWidth;\n    };\n\n    validateMinSize(qrDimensions.width);\n    validateMinSize(qrDimensions.height);\n    qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);\n  };\n\n  Html5Qrcode.prototype.validateQrboxConfig = function (qrboxSize) {\n    if (typeof qrboxSize === \"number\") {\n      return;\n    }\n\n    if (typeof qrboxSize === \"function\") {\n      return;\n    }\n\n    if (qrboxSize.width === undefined || qrboxSize.height === undefined) {\n      throw \"Invalid instance of QrDimensions passed for \" + \"'config.qrbox'. Both 'width' and 'height' should be set.\";\n    }\n  };\n\n  Html5Qrcode.prototype.toQrdimensions = function (viewfinderWidth, viewfinderHeight, qrboxSize) {\n    if (typeof qrboxSize === \"number\") {\n      return {\n        width: qrboxSize,\n        height: qrboxSize\n      };\n    } else if (typeof qrboxSize === \"function\") {\n      try {\n        return qrboxSize(viewfinderWidth, viewfinderHeight);\n      } catch (error) {\n        throw new Error(\"qrbox config was passed as a function but it failed with \" + \"unknown error\" + error);\n      }\n    }\n\n    return qrboxSize;\n  };\n\n  Html5Qrcode.prototype.setupUi = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n    if (internalConfig.isShadedBoxEnabled()) {\n      this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);\n    }\n\n    var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? {\n      width: viewfinderWidth,\n      height: viewfinderHeight\n    } : internalConfig.qrbox;\n    this.validateQrboxConfig(qrboxSize);\n    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n\n    if (qrDimensions.height > viewfinderHeight) {\n      this.logger.warn(\"[Html5Qrcode] config.qrbox has height that is\" + \"greater than the height of the video stream. Shading will be\" + \" ignored\");\n    }\n\n    var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;\n    var defaultQrRegion = {\n      x: 0,\n      y: 0,\n      width: viewfinderWidth,\n      height: viewfinderHeight\n    };\n    var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;\n    var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);\n    var context = canvasElement.getContext(\"2d\");\n    context.canvas.width = qrRegion.width;\n    context.canvas.height = qrRegion.height;\n    this.element.append(canvasElement);\n\n    if (shouldShadingBeApplied) {\n      this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);\n    }\n\n    this.createScannerPausedUiElement(this.element);\n    this.qrRegion = qrRegion;\n    this.context = context;\n    this.canvasElement = canvasElement;\n  };\n\n  Html5Qrcode.prototype.createScannerPausedUiElement = function (rootElement) {\n    var scannerPausedUiElement = document.createElement(\"div\");\n    scannerPausedUiElement.innerText = \"Scanner paused\";\n    scannerPausedUiElement.style.display = \"none\";\n    scannerPausedUiElement.style.position = \"absolute\";\n    scannerPausedUiElement.style.top = \"0px\";\n    scannerPausedUiElement.style.zIndex = \"1\";\n    scannerPausedUiElement.style.background = \"yellow\";\n    scannerPausedUiElement.style.textAlign = \"center\";\n    scannerPausedUiElement.style.width = \"100%\";\n    rootElement.appendChild(scannerPausedUiElement);\n    this.scannerPausedUiElement = scannerPausedUiElement;\n  };\n\n  Html5Qrcode.prototype.scanContext = function (qrCodeSuccessCallback, qrCodeErrorCallback) {\n    var _this = this;\n\n    if (this.stateManagerProxy.isPaused()) {\n      return Promise.resolve(false);\n    }\n\n    return this.qrcode.decodeAsync(this.canvasElement).then(function (result) {\n      qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));\n\n      _this.possiblyUpdateShaders(true);\n\n      return true;\n    }).catch(function (error) {\n      _this.possiblyUpdateShaders(false);\n\n      var errorMessage = Html5QrcodeStrings.codeParseError(error);\n      qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));\n      return false;\n    });\n  };\n\n  Html5Qrcode.prototype.foreverScan = function (internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {\n    var _this = this;\n\n    if (!this.shouldScan) {\n      return;\n    }\n\n    if (!this.localMediaStream) {\n      return;\n    }\n\n    var videoElement = this.videoElement;\n    var widthRatio = videoElement.videoWidth / videoElement.clientWidth;\n    var heightRatio = videoElement.videoHeight / videoElement.clientHeight;\n\n    if (!this.qrRegion) {\n      throw \"qrRegion undefined when localMediaStream is ready.\";\n    }\n\n    var sWidthOffset = this.qrRegion.width * widthRatio;\n    var sHeightOffset = this.qrRegion.height * heightRatio;\n    var sxOffset = this.qrRegion.x * widthRatio;\n    var syOffset = this.qrRegion.y * heightRatio;\n    this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);\n\n    var triggerNextScan = function triggerNextScan() {\n      _this.foreverScanTimeout = setTimeout(function () {\n        _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);\n      }, _this.getTimeoutFps(internalConfig.fps));\n    };\n\n    this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function (isSuccessfull) {\n      if (!isSuccessfull && internalConfig.disableFlip !== true) {\n        _this.context.translate(_this.context.canvas.width, 0);\n\n        _this.context.scale(-1, 1);\n\n        _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function () {\n          triggerNextScan();\n        });\n      } else {\n        triggerNextScan();\n      }\n    }).catch(function (error) {\n      _this.logger.logError(\"Error happend while scanning context\", error);\n\n      triggerNextScan();\n    });\n  };\n\n  Html5Qrcode.prototype.onMediaStreamReceived = function (mediaStream, internalConfig, areVideoConstraintsEnabled, clientWidth, qrCodeSuccessCallback, qrCodeErrorCallback) {\n    var _this = this;\n\n    var $this = this;\n    return new Promise(function (resolve, reject) {\n      var setupVideo = function setupVideo() {\n        var videoElement = _this.createVideoElement(clientWidth);\n\n        $this.element.append(videoElement);\n        videoElement.onabort = reject;\n        videoElement.onerror = reject;\n\n        var onVideoStart = function onVideoStart() {\n          var videoWidth = videoElement.clientWidth;\n          var videoHeight = videoElement.clientHeight;\n          $this.setupUi(videoWidth, videoHeight, internalConfig);\n          $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);\n          videoElement.removeEventListener(\"playing\", onVideoStart);\n          resolve(null);\n        };\n\n        videoElement.addEventListener(\"playing\", onVideoStart);\n        videoElement.srcObject = mediaStream;\n        videoElement.play();\n        $this.videoElement = videoElement;\n      };\n\n      $this.localMediaStream = mediaStream;\n\n      if (areVideoConstraintsEnabled || !internalConfig.aspectRatio) {\n        setupVideo();\n      } else {\n        var constraints = {\n          aspectRatio: internalConfig.aspectRatio\n        };\n        var track = mediaStream.getVideoTracks()[0];\n        track.applyConstraints(constraints).then(function (_) {\n          return setupVideo();\n        }).catch(function (error) {\n          $this.logger.logErrors([\"[Html5Qrcode] Constriants could not \" + \"be satisfied, ignoring constraints\", error]);\n          setupVideo();\n        });\n      }\n    });\n  };\n\n  Html5Qrcode.prototype.createVideoConstraints = function (cameraIdOrConfig) {\n    if (typeof cameraIdOrConfig == \"string\") {\n      return {\n        deviceId: {\n          exact: cameraIdOrConfig\n        }\n      };\n    } else if (typeof cameraIdOrConfig == \"object\") {\n      var facingModeKey = \"facingMode\";\n      var deviceIdKey = \"deviceId\";\n      var allowedFacingModeValues_1 = {\n        \"user\": true,\n        \"environment\": true\n      };\n      var exactKey = \"exact\";\n\n      var isValidFacingModeValue = function isValidFacingModeValue(value) {\n        if (value in allowedFacingModeValues_1) {\n          return true;\n        } else {\n          throw \"config has invalid 'facingMode' value = \" + (\"'\" + value + \"'\");\n        }\n      };\n\n      var keys = Object.keys(cameraIdOrConfig);\n\n      if (keys.length !== 1) {\n        throw \"'cameraIdOrConfig' object should have exactly 1 key,\" + (\" if passed as an object, found \" + keys.length + \" keys\");\n      }\n\n      var key = Object.keys(cameraIdOrConfig)[0];\n\n      if (key !== facingModeKey && key !== deviceIdKey) {\n        throw \"Only '\" + facingModeKey + \"' and '\" + deviceIdKey + \"' \" + \" are supported for 'cameraIdOrConfig'\";\n      }\n\n      if (key === facingModeKey) {\n        var facingMode = cameraIdOrConfig.facingMode;\n\n        if (typeof facingMode == \"string\") {\n          if (isValidFacingModeValue(facingMode)) {\n            return {\n              facingMode: facingMode\n            };\n          }\n        } else if (typeof facingMode == \"object\") {\n          if (exactKey in facingMode) {\n            if (isValidFacingModeValue(facingMode[\"\" + exactKey])) {\n              return {\n                facingMode: {\n                  exact: facingMode[\"\" + exactKey]\n                }\n              };\n            }\n          } else {\n            throw \"'facingMode' should be string or object with\" + (\" \" + exactKey + \" as key.\");\n          }\n        } else {\n          var type_1 = typeof facingMode;\n          throw \"Invalid type of 'facingMode' = \" + type_1;\n        }\n      } else {\n        var deviceId = cameraIdOrConfig.deviceId;\n\n        if (typeof deviceId == \"string\") {\n          return {\n            deviceId: deviceId\n          };\n        } else if (typeof deviceId == \"object\") {\n          if (exactKey in deviceId) {\n            return {\n              deviceId: {\n                exact: deviceId[\"\" + exactKey]\n              }\n            };\n          } else {\n            throw \"'deviceId' should be string or object with\" + (\" \" + exactKey + \" as key.\");\n          }\n        } else {\n          var type_2 = typeof deviceId;\n          throw \"Invalid type of 'deviceId' = \" + type_2;\n        }\n      }\n    }\n\n    var type = typeof cameraIdOrConfig;\n    throw \"Invalid type of 'cameraIdOrConfig' = \" + type;\n  };\n\n  Html5Qrcode.prototype.computeCanvasDrawConfig = function (imageWidth, imageHeight, containerWidth, containerHeight) {\n    if (imageWidth <= containerWidth && imageHeight <= containerHeight) {\n      var xoffset = (containerWidth - imageWidth) / 2;\n      var yoffset = (containerHeight - imageHeight) / 2;\n      return {\n        x: xoffset,\n        y: yoffset,\n        width: imageWidth,\n        height: imageHeight\n      };\n    } else {\n      var formerImageWidth = imageWidth;\n      var formerImageHeight = imageHeight;\n\n      if (imageWidth > containerWidth) {\n        imageHeight = containerWidth / imageWidth * imageHeight;\n        imageWidth = containerWidth;\n      }\n\n      if (imageHeight > containerHeight) {\n        imageWidth = containerHeight / imageHeight * imageWidth;\n        imageHeight = containerHeight;\n      }\n\n      this.logger.log(\"Image downsampled from \" + (formerImageWidth + \"X\" + formerImageHeight) + (\" to \" + imageWidth + \"X\" + imageHeight + \".\"));\n      return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n    }\n  };\n\n  Html5Qrcode.prototype.clearElement = function () {\n    if (this.stateManagerProxy.isScanning()) {\n      throw \"Cannot clear while scan is ongoing, close it first.\";\n    }\n\n    var element = document.getElementById(this.elementId);\n\n    if (element) {\n      element.innerHTML = \"\";\n    }\n  };\n\n  Html5Qrcode.prototype.createVideoElement = function (width) {\n    var videoElement = document.createElement(\"video\");\n    videoElement.style.width = width + \"px\";\n    videoElement.muted = true;\n    videoElement.setAttribute(\"muted\", \"true\");\n    videoElement.playsInline = true;\n    return videoElement;\n  };\n\n  Html5Qrcode.prototype.possiblyUpdateShaders = function (qrMatch) {\n    if (this.qrMatch === qrMatch) {\n      return;\n    }\n\n    if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {\n      this.borderShaders.forEach(function (shader) {\n        shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;\n      });\n    }\n\n    this.qrMatch = qrMatch;\n  };\n\n  Html5Qrcode.prototype.possiblyCloseLastScanImageFile = function () {\n    if (this.lastScanImageFile) {\n      URL.revokeObjectURL(this.lastScanImageFile);\n      this.lastScanImageFile = null;\n    }\n  };\n\n  Html5Qrcode.prototype.createCanvasElement = function (width, height, customId) {\n    var canvasWidth = width;\n    var canvasHeight = height;\n    var canvasElement = document.createElement(\"canvas\");\n    canvasElement.style.width = canvasWidth + \"px\";\n    canvasElement.style.height = canvasHeight + \"px\";\n    canvasElement.style.display = \"none\";\n    canvasElement.id = isNullOrUndefined(customId) ? \"qr-canvas\" : customId;\n    return canvasElement;\n  };\n\n  Html5Qrcode.prototype.getShadedRegionBounds = function (width, height, qrboxSize) {\n    if (qrboxSize.width > width || qrboxSize.height > height) {\n      throw \"'config.qrbox' dimensions should not be greater than the \" + \"dimensions of the root HTML element.\";\n    }\n\n    return {\n      x: (width - qrboxSize.width) / 2,\n      y: (height - qrboxSize.height) / 2,\n      width: qrboxSize.width,\n      height: qrboxSize.height\n    };\n  };\n\n  Html5Qrcode.prototype.possiblyInsertShadingElement = function (element, width, height, qrboxSize) {\n    if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {\n      return;\n    }\n\n    var shadingElement = document.createElement(\"div\");\n    shadingElement.style.position = \"absolute\";\n    var rightLeftBorderSize = (width - qrboxSize.width) / 2;\n    var topBottomBorderSize = (height - qrboxSize.height) / 2;\n    shadingElement.style.borderLeft = rightLeftBorderSize + \"px solid #0000007a\";\n    shadingElement.style.borderRight = rightLeftBorderSize + \"px solid #0000007a\";\n    shadingElement.style.borderTop = topBottomBorderSize + \"px solid #0000007a\";\n    shadingElement.style.borderBottom = topBottomBorderSize + \"px solid #0000007a\";\n    shadingElement.style.boxSizing = \"border-box\";\n    shadingElement.style.top = \"0px\";\n    shadingElement.style.bottom = \"0px\";\n    shadingElement.style.left = \"0px\";\n    shadingElement.style.right = \"0px\";\n    shadingElement.id = \"\" + Constants.SHADED_REGION_ELEMENT_ID;\n\n    if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {\n      this.hasBorderShaders = false;\n    } else {\n      var smallSize = 5;\n      var largeSize = 40;\n      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, 0, true);\n      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, 0, false);\n      this.insertShaderBorders(shadingElement, largeSize, smallSize, qrboxSize.height + smallSize, 0, true);\n      this.insertShaderBorders(shadingElement, largeSize, smallSize, qrboxSize.height + smallSize, 0, false);\n      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, -smallSize, true);\n      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, qrboxSize.height + smallSize - largeSize, -smallSize, true);\n      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, -smallSize, false);\n      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, qrboxSize.height + smallSize - largeSize, -smallSize, false);\n      this.hasBorderShaders = true;\n    }\n\n    element.append(shadingElement);\n  };\n\n  Html5Qrcode.prototype.insertShaderBorders = function (shaderElem, width, height, top, side, isLeft) {\n    var elem = document.createElement(\"div\");\n    elem.style.position = \"absolute\";\n    elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;\n    elem.style.width = width + \"px\";\n    elem.style.height = height + \"px\";\n    elem.style.top = top + \"px\";\n\n    if (isLeft) {\n      elem.style.left = side + \"px\";\n    } else {\n      elem.style.right = side + \"px\";\n    }\n\n    if (!this.borderShaders) {\n      this.borderShaders = [];\n    }\n\n    this.borderShaders.push(elem);\n    shaderElem.appendChild(elem);\n  };\n\n  Html5Qrcode.prototype.showPausedState = function () {\n    if (!this.scannerPausedUiElement) {\n      throw \"[internal error] scanner paused UI element not found\";\n    }\n\n    this.scannerPausedUiElement.style.display = \"block\";\n  };\n\n  Html5Qrcode.prototype.hidePausedState = function () {\n    if (!this.scannerPausedUiElement) {\n      throw \"[internal error] scanner paused UI element not found\";\n    }\n\n    this.scannerPausedUiElement.style.display = \"none\";\n  };\n\n  Html5Qrcode.prototype.getTimeoutFps = function (fps) {\n    return 1000 / fps;\n  };\n\n  return Html5Qrcode;\n}();\n\nexport { Html5Qrcode };","map":null,"metadata":{},"sourceType":"module"}